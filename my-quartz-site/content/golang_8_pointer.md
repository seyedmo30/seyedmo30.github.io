### escape analysis


یک تکنیک است در گولنگ که تصمیم بگیرد این داده درون استک ذخیره شود و یا درون هیپ


چه زمانی یه متغییر اسکیپ میکنه؟  زمانی که از فانکشن ریترن میشه ، زمانی که به یه گلوبال وریبل میشینه . در غیر این صورت اسکیپ نمیشه و یا بعد از پایان اسکوپ ریکلیم میشه ، یا اگر پوینتری بود ، فیلدش ریکلیم میشه و بعدا داده اش هم گاربج کالکتور پاک میکنه

میشه رفتار ها و انواع مفاهیم مرتب با مموری و ذخیره  رو از چند منظر دید 

## data allocation (stack or heap)

بعدن باید مطالب به این جا آورده شود

## type of the variable(Reference Types vs Value Types) 

+ **`Value Types`**


تایپ هایی که در ورونش واقعن مقدار آن ریخته میشود و به این معنی که هر بار به فانکشنی پاس میدهیم  یک کپی از آن گرفته میشه و کپی در فانکشن جدید ریخته میشه ، به این ترتیب داده در اسکوپ جدید استفاده می شه و بعد از پایان کار فانکشن داده پاک میشه ( چون تو استک هست) 

داده های زیر از این نوع هستند

`int,  , bool , string , Structs ,Arrays`

زمانی که بخواهیم تایپ ما یک پوینتر باشد به طوری که مقدار و رفرنس تایپ ما (Reference Types vs Value Types)  هر دو روی هیپ ذخیره شود از `new()` استفاده می کنیم

+ **`Reference Types`**

این تاپ ها درون خود آدرس دارن ( شبیه به پایتون وقتی یه کلاس رو توی یه متغییر جدید  کپی م کردیم ) و نه داده ی واقعی و وقتی آن را در متغییر جدید میریزیم ، در حقیقت آدرس رو میریزیم

هرگاه برای ساخت اینا از دستور `make()`  استفاده کنیم ، بر روی هیپ آن ها رو الوکیت می کنیم . توجه شود با`new()` هم می توان تولید کرد



`interfaces , Slices,  , Maps , Channels , Pointers , functions`

همچنین توجه شود `**zero init**` این نوع تایپ ها  `nil` هست

```go
var s1 = []int{1, 2, 3}  
var s2 = s1 // s2 points to the same underlying array as s1  

m1 := make(map[string]int)  
m1["one"] = 1  
m2 := m1 // m2 refers to the same map as m1

ch1 := make(chan int)  
ch2 := ch1 // ch2 refers to the same channel 

var x int = 42  
var p *int = &x // p is a pointer to x  
```

همچنین اگر این ها به تابعی پاس داده شوند ، تابع می تواند داده های سوپر فانکشن رو تغییر بده 

```go
func modifySlice(s []int) {  
    s[0] = 100 // Modifying the first element of the slice  
}  

func modifyValue(n *int) {  
    *n = 100 // Modifying the value at the pointer's address  
}  


func main() {  

    original := []int{1, 2, 3}  
    modifySlice(original)  
    fmt.Println(original) // Output: [100 2 3]  


    original := 42  
    modifyValue(&original) // Passing the address of original  
    fmt.Println(original)   // Output: 100  
}  
```

توجه شود این که `Reference Types` است ربطی به این نداره که در `heap or stack`  ذخیره بشه

+ `Slices`

خود وریبل اسلایس در استک ذخیره میشود اما محتوات درونش توی هیپ است به خصوص اگر بزرگ شود یا از make  برای ایجاد استفاده کنیم


+ `Maps`

همیشه بر روی heap ذخیره میشه ، شاید خود وریبلی که رفرنس رو نگه میداره بر روی استک ذخیره شه اما داده های درونش توی هیپ هست 



+ `Pointers`
هر جا پوینتر ساخته شود  در همان جا مشخص میشود مثلن اگر در همان فانکشن ساخته شود در استک ذخیره میشود

این بستگی به داده ای که اشاره می کند دارد ، اگر داده درونش لوکال یا درون فانکشن  باشد و `Value Types` باشد آنگاه اشاره به استک دارد اما اگر با `new() or make()`  ساخته شود ، آنگاه به هیپ اساره دارد

## Mutable vs. Immutable Types

به این معنا که متغییر قابل تغییر نیست یعنی که آپدیت مقدار درون آن باعث تغییر خانه ی حافظه میشود

+ **Immutable Types**

این داده ها نباید تغییری داشته باشند (like int and string)  و در صورت تغییر کپی شده و در خانه ی جدید از حافظه قرار میگیرند

### tips

+ **Dereferencing a pointer**

این که از آدرس به مقدار برسیم میگن


+ همیشه این دو در برابر هم هستند :

+ + **pointer variables** -- which point to a memory address

+ + **value variables(Non-Pointer)** -- which hold the actual data


### value vs reference type

+ Value types
آرایه ها و استراکت ها , int ,string


+ reference types
چنل ها ، اسلایس ها ، مپ ,finc , pointer


+ زمانی که فانکشن کال بشه اگر پارامتر های ورودی رفرنس باشن ، داده کپی نمیشه اما روی داده ها در اسکوپ بالا تر هم تاثیر میزاره ، اما اگر تایپش ولیو باشه ، کپی میشه بعد از ریترن از استک پاک میشه

+ تقریبا رفرنس توی هیپ هست و ولیو توی استک اما  هیچ ارتباط قطعی بین تایپ رفرنس و هیپ و تایپ ولیو و استک نیست

برای مثال اگر درون فانکشن تایپ رفرنسی تعریف کنیم اما به بیرون انتقال ندیم در استک فانکشن هست , یا زمانی که درون استراکت ، یه فیلد رف تایپ بسازیم ، اون بخش میره تو هیپ ، همچنین وقتی اگه یه تایپ رفرنس رو پاس بدیم به یه فانکشن ، اون تو استکی که فانکشن جدید میسازه به صورت استکه



+ تایپ رفرنس توسط gc مدیریت میشه اما ولیو مستقیم reclaim  میشه


+ ولیو مستقیم ساخته میشه  , initiate . اما رفرنس با make , new  ساخته میشه

+ ولیور قابل مقایسه هست comprasion اما رفرنس نیست ، جز nil

+  قطعی نه ولی معمولن ولیو immiutable هست اما رفرنس  mutable ، مثال استثنا زمانی که به یه فانکشن آدرس یه استراکت میدیم توجه شه که خود استراکت ، ولیو تایپ است اما اگر ادرس پاس داده بشه ، میشه فیلد های درونیش رو تغییر داد 




```go
package main

import (
    "fmt"

)

func modifySlice(s []int) {
    s[0] = 100 // This will modify the original slice
}

func main() {
    nums := []int{1, 2, 3}
    modifySlice(nums)
    fmt.Println(nums) // Output: [100, 2, 3]
}
```


#### الگوریتم های gc

+ **Mark-and-Sweep Algorithm**

به این صورت که متغییر های گلوبال برچسب میزنه و کاری نداره ولی به متغییر هایی که در ریشه قابل 

دسترسی نیستند ،  موقعی که گاربج کالکتور ران میشه ، اینا رو شناسایی و جارو میکنه اصطلاحا اینا 
reclaimed نیستن 

#### tips

مدیریت حافظه در heap توسط gc  است اما در استک با پترن lifo بدون نیاز به gc  توسط runtime اتوماتیک reclaim میشه



+ نمیدونم درسته یا غلط اما ai میگه gc  در گوروتین همواره اجرا میشه و هیچ وقت استاپ نمیشه اما در کل برنامه همواره اجرا نیست ، 

+ میتونیم با مقدار دهی انو وریبل GOGC میزان درصد هیپ برای فعال شدن گاربج کالکتور رو مدیریت
+ هر گوروتین که میسازیم برای خودش استک جدید داره با مقدار کوچیک 2kB و در صرت نیاز shrink میکنه در حالی که heap بین همه مشترکه و یکی از 

خوبیاش اینه که بشه در اسکوپ های بالا تر یا گوروتین های دیگه هم استفاده کرد


### nil
```go

A *int
Print a --> nil

0x0 == nil

B =New(int)           ---------> حتی اگر B  رو مقدار دهی هم نکنیم ، nil نیست و یه آدرس است
```





ابتدا توجه شود نباید از اشاره گر ها در همه جا استفاده شود . گاهی شاید هزینه را  بیشتر کند

برای ساخت استراکت باید دقت کرد اگر استراکت کوچک است ، بهتر است مقدار آن را بسازید زیرا در `stack` قرار می گیرد و گاربج کالکتور راحت تر آن را مدیریت می کند . 

همچنین استراکت پوینتری در گوروتین های دیگر نا امن هستند .

یکی از موارد خوب برای استفاده ، زمانی است که فیلد های درونی اش همواره در حال تغییر باشد . همچنین در صورتی که استراکت خیلی بزرگ باشد ، و در نتیجه هزینه ی کپی خیلی زیاد باشد .

همچنین زمانی که علاوه بر مقدار `zero init` مثدار `nil` هم نیاز دارد مانند زمانی که داده الزامی نیست و می خواهیم بدانیم داده خالی ارسال شده یا اصلن پر نشده



### Pointer in go 

```go
_________ -> error

var x *int

*x = 20 


_________ -> worked

px := new(int)

*px = 30

x = px

```
 توجه شود به هیچ وجه از پوینتر اینترفیس ( *interface{} ) استفاده نشود  .

 زیرا مقدار داخل اینترفیس در حقیقت مقدار استراکت ایمپلمنت شده نیست ، در حقیقت پوینتری از آن است .
 
 

# Pointer of for Range Loop Variable


دقت شود در صورتی که حلقه بر روی دیتا استراکچر ها زده می شود ، المنت پیمایش شده  بر روی یک خانه ی حافظه ذخیره می شود 

در نتیجه شاید با پرینت آن وریبل ، تغییر کند ، اما آدرس یکسان است :)

حال اگر ما به جای value المنت ، آدرس آن را استفاده کنیم ، در تمام پیمایش ها آدرس یکسان است در نتیجه تمامی لیست خروجی یکسان است .

    Dog with name <{Ghost}> and pointer: <0xc000010200>
    Dog with name <{Bruno}> and pointer: <0xc000010200>
    Dog with name <{Lucky}> and pointer: <0xc000010200>


راه حل :)


    for k := range src {
        key := k
        dst = append(dst, &key)
    }

https://medium.com/swlh/use-pointer-of-for-range-loop-variable-in-go-3d3481f7ffc9

https://levelup.gitconnected.com/go-for-range-slice-bug-lessons-learned-fa401d5d8c9a


### zero-initialized

0 for numeric types, "" for strings, nil for pointers




 وقتی از new استفاده می کنیم ، درون هیپ ریخته میشه ، فیلد ها zero-initialized پر میشن ، مقادیر دوباره باید به پوینتر اساین شوند
# Method Receiver - Pointer v/s Value

در رسیور های یک استراکت می توانیم ازپروپرتی ها یا فیلد های استراکت هم استفاده کنیم ، برای این منظور از رسیور استفاده می کنیم ، همچنین برای مشخص کردن متد های ایمپلمنت شده برای اینترفیس هم از آن استفاده می شود . 

تفاوت رسیور با پونتر و مقدار :

به طور کلی رسیور با پوینتر بهتر است اما :

روش با گیرنده های مقدار یک کپی از یک شی را تغییر می دهد و شی اصلی بدون تغییر باقی می ماند پس داده ها کپسوله تر ( ایمن تر هستند ) در استفاده کاکارنسی  ریسیور ولیو ایمن تر هستند.

اگر می خواهید فیلد های گیرنده را تغییر دهید، مقدار آن را دستکاری کنید، از گیرنده اشاره گر استفاده کنید.

گیرنده Pointer از کپی کردن مقدار در هر فراخوانی متد اجتناب می کند. این می تواند کارآمدتر باشد اگر گیرنده یک ساختار بزرگ باشد،

اگر گیرنده map, func or chan است، از اشاره گر به آن استفاده نکنید.

اگر گیرنده یک struct, array or slice است و هر یک از عناصر آن نشانگر چیزی است که ممکن است در حال mutate باشد، یک گیرنده اشاره گر را ترجیح دهید،


### Common Usage Scenarios

```go
type Person struct {  
	Name string  
	Age  int  
}  


var p1 Person

p2 := Person{Name: "Salam", Age: 20}

p3 := new(Person)

fmt.Printf("p1: %+v\n", p1) // p1: {Name: Age:0}

fmt.Printf("p2: %+v\n", p2) // p2: {Name:Salam Age:20}

fmt.Printf("p3: %+v\n", p3) // p3: &{Name: Age:0}


```

+ در اولی و دومی هیچ فرقی ندارند هر دو در وریبل معمولی هستند و کاربردشان در همین اسکوپ است ، بعد از استفاده نیازی به آنها نیست

+ در دومی literal  مقدار دهی شده ولی در اولی Zero value (default) شده

+ اما در سومی وریبل پوینتری است و کاربردش زمانی است که استراکت بزرگ باشد و بخواهیم چندین بار پاس بدیم و استفاده کنیم

+ در اولی و سومی  Name= "" and Age= 0 

+ در این مثال p3 **Pointer Variable** 

+ در این مثال *Person یک **Pointer Type** هست
