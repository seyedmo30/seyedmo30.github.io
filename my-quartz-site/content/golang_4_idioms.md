value مقدار ( مثل ۶ یا علی )

variable ظرفی که ولیو داخلش ریخته می شه (مثل کانست یا لت یا ور)

data type نوع ظرف ( مثل استرینگ یا اینت)

data structure مجموعه یا گروهی از دیتا تایپ ها (مثل لیست یا درخت یا مپ یا دیکشنری)

mutable data types  داده هایی که با تغییر مقدار آن ، مکان آن ها در مموری  تغییر نکند مانند اینت 

داده های میوتیبل : 
Slice - Array - Map - Channels 

ایمیوتیبل : 
Boolean - Int - Float - Pointers - String - Interfaces

اگر شک دارید که عدد ایمیوتیبل است ، لینک مظالعه شود : 
https://stackoverflow.com/questions/71589811/go-ints-and-strings-are-immutable-or-mutable/71590289#71590289


**type casting** اگر بخواهیم تایپ یک ظرف(وریبل) را تغییر دهیم - مثلا اینت به فلوت- که گو ندارد

 - **conversion** 

 برای این که ولیو(مقدار) با تایپ خاص ، در یک ظرف(وریبل) با تایپ متفاوت بریزیم ، راه هایی دارد که آنها را کانورژن می گوییم

 - **race condition** 

 اگر دو دستور بخواهند مقدار یک وریبل را همزمان تغییر دهند ، برای جلو گیری از ریس کاندیشن از mutex استفاده می کنیم

 - **type embedding** 

 به این معناست که ما می توانیم هرتایپی را درون استراکت بزاریم ، اینجا مقصود اینترفیس است که می توان در استراکت ، یک پراپرتی باشد

 توجه شود نباید **struct embedding** و **Field Containment** را با هم اشتباه بگیریم ، در امبد کردن در حقیقت آن استراکت بخش از سوپر استراکت است و برای دسترسی نیازی به نام امبد شده نیست

 همچنین برای کار با جیسون ، زمانی که امبد می کنیم ، در حقیقت هیچ کلیدی در نظر نمی گیرد
 ```go

type Outer struct {
    Inner // Inner is embedded
}

type GetOrderInfoBodyResponse struct {
    Message      string               `json:"message"`
    ResultCode   int                  `json:"resultCode"`
    ResponseBody GetOrderInfoResponse `json:"responseBody"` // This is a field, not embedding
}
 ```


 - **deadlock** vs **blocking**

 زمانی که بافر چنل ها پر شود، وگوروتین ها منتظرخالی شدن چنل برای ریختن داده در آن هستند ، در حالی که خالی نمی شود ، اصطلاحا می گن ددلاک شده ،همچنین اگه چنل خالی باشه و یک گوروتین منتظر که داده از چنل برداره و همه گوروتین ها منتظرن ، باز هم دد لاک میشه


همچنین اگه توسط mutex  لاک شده در حالی که هیچ وقت گوروتینی اون رو آنلاک نمیکنه ، ددلاک رخ میده

درحالی که بلاک شدن یه چیز عادی هست ، گوروتین ها زمانی که چنلی رو کانسوم ، پرودیوس میکنن ، احتمالا بلاک بشن ، همچنین گوروتینی که توسط mutex  منتظر هست ، بلاک شده

اما تفاوت زمانی هست که تمام گوروتین ها بلاک باشن و هیچ گوروتینی نتونه یکی دیگه رو از بلاکی در بیاره ،در این صورت ددلاک رخ میده


 - **Function/method overloading** 

    قابلیتی است که بعضی زبان های برنامه نویسی از جمله گو ندارند و می توان در یک پکیج بیش از یک فانکشن با اسم مشابه ساخت ، مثلا چند متد هم نام که هر کدام پارامتر های مختلف میگیرند

در گولنگ به جای این قابلیت از روش های غیر مستقیم می توان استفاده کرد

+ + استفاده از وریدیک فانکشن ها

+ + چندین فانکشن که اسماشون تشابه داره ولی تهش متفاوت میشه مثل addInt یا addFloat

+ + استفاده از ریسیور ها و تعریف اولیه در اینترفیس


 - **Type Assertion** 

 اگر بخواهیم تایپ یک اینترفیس را مشخص کنیم 

 ```go
 t, isSuccess := i.(string)
 ```

 - **func prototype/signature** 

 در حقیقت مجموع نام تابع، لیست پارامتر و ریترن را می گوند

+ **interface compliance assertion**
زمانی که بخواهیم مطمعن شویم که اینترفیس کانکریت شده ،  و همچنین خانایی استراکت و اینترفیس  بهتر شود از این استفاده می کنیم

```go
//Compile-time interface assertion

var _ Shape = (*Rectangle)(nil) //Shape interface and Rectangle struct
```


+ **blank identifier**    شناسه خالی

اگر یک فانکشن  خروجی داشت و ما خروجی ها را نادیده گرفته‌ایم ، آن را با  _  نمایش می دهیم یعنی خروجی را نادیده می گیریم
```go
      _,res := Double(8)
```

 - **String formatting with placeholders** 

  میتوان داخل استرینگ با علامت درصد مقدار جایگذاری کرد

 - **Variadic Functions** 

یک فانکشن می توان صفر یا بی نهایت ورودی بگیرد و با سه نقطه مشخص می کنیم

 می توان زمانی که پارامتر آپشنال است استفاده کنیم همچنین تنها در هر فانکشن یک بار می شه استفاده کرد و باید آخری باشه

```go
func functionName(params ...Type)
```
 - **Composite literals** 

 در صورتی که یک دیتا استراکچر تعریف کنیم و مقدار دهی اولیه کنیم ، در حقیقت آن را لیترال تعریف کرده ایم ، کار بردش زمانی است که می دانیم ظرفیت داده چقدر است .

در بیشتر دیتا استراکچر ها در داخل پرانتز بعد اینیت ، مشخص می شود
```go

arr := [3]int{1, 2, 3}
Slice := []int{1, 2, 3}
bt := []byte("salam")
m :=map[string]int{ "Alice": 30,"Bob":   25,}
gg := struct{ name string }{name : "ali"}  
gg := struct{}{} 
```

### empty struct 

دقت شود  هیچ جایی در حافظه نمی گیرد

+ لیستی از داده ها ، به جای آرایه یا اسلایس می توانیم از مپ زیر استفاده کنیم ، یکی از کاربرد های این ، سرچ سریع در مپ و گرفتن وجود یا عدم وجود است :

```go
         map_obj := make(map[string]struct{})
```
+ ارسال سیگنال به چنل ها البته بهتر است از کانتکست استفاده کنیم

## different GoPATH and GoROOT 

The GoPATH determines the root of the workspace whereas the GoROOT determines the location of Go SDK .

گو روت فایل نصبی است و درون bin آن ، باینری است که با آن کار می کنیم . اما GOPATH متغییر محیطی است ( go env بزنیم ) و مواردی چون پکیج ها و کامند های کامپلر شده ( مانند swag )  را درون خود دارد . 


###   export GOPATH=$HOME/go

مثلا هر پکیجی که نصب می کنیم در GOPATH می رود :
```
/home/seyed/go/pkg/mod/github.com/gin-gonic/
```
و در صورتی که پکیج کامپایل شود در آدرس زیر می رود

```   
   /home/seyed/go/bin/swag
```
###   export GOROOT=/usr/local/go
 فایل اصلی گو که کد را کامپایل می کند 

```
/usr/local/go/bin/go
```
 پکیج های بیلتین

```     
/usr/local/go/src/fmt/
```


### mod tidy - install - get - mod download

+ go install



زمانی که بخواهیم یه باینری **Go CLI tool** رو نصب کنیم ، نیاز به **go mod**  نداره و هر جا می تونه اجرا شه

`go install github.com/rakyll/hey@latest`

+ go get

برای نصب نیازمندی ها در ماژول و آپدیت  **go mod**  

`go get github.com/segmentio/kafka-go`

+ go mod tidy

سینک کردن پکیج های ایمپورت شده و  **go mod**  

پایک کردن از **go mod**  زمانی که از پکیجی دیگه استفاده نمی کنیم یا افزودن بدون **get**

+ go mod download

از لیست **go mod**  می خونه و تا جایی که بتونه از لوکال کش می خونه دقت شود **go.mod** آپریت نمی شه

در زمان بیلد گرفتن آفلاین استفاده میشه ، همچنین در زمان پایپلاین با استفاده از کش

`go mod download`

### **Use Named Return Values** 

با این روش میشه همون اول توی فانکشن ، نام های خروجی رو مشخص کرد و در پایان تنها ریترن بدون پارام کرد
 
 ```go
 func calculate(x, y int) (sum int, product int) {
    sum = x + y
    product = x * y
    return // no need to explicitly return named values
}
```

## **variable types**

 + **visibility across package**

دسته بندی انواع متغییر از جهت دیدن آنها در پکیج ها

+ + **Exported variables**

با حرف بزرگ و در جاهای دیگه هم میشه دید

+ + **UnExported variables**

با حرف کوچک و در بیرون پکیج قابل مشاهده نیست

+ **accessibility throughout the entire package**

+ + **Global variables**

درون  فانکشن یا متدی نیستند و در بدنه ی پکیج هستند و قابل مشاهده و تغییر توسط تمامی متد های آن پکیج هست

**نکته** در گوروتین ها استفاده از گلوبال ها توصیه نمی شود زیرا می توان به طور همزمان به آنها دسترسی پیدا کرد و race condition رخ می ده


+ + **Local variables**

درون فانکشن یا  ریسیور هستند و مقدارش تنها توسط فانکشن قابل خواندن است یعنی اگر تغییر دهیم ، سوپر فانکشن  همان مقدار قبلی است


### functional options pattern

یه دیزاین پترن برای زمانی که بخواهیم یه کانستراکتور برای یه استراکت بنویسیم و فیلد های اون رو آپشنال پر کنیم

برای این کار برای دریافت هر فیلد ، باید یه متد بتوسیم که اون فیلد خاص رو بگیره و بریزه تو استراکت ، در نهایت یه حلقه ، اون ها رو پیمایش می کنه و میریزه تو استراکت


### Variable Scope:

مشخص میکند محدوده ی وریبل رو ، گاهی اسکوپ یک وریبل داخل پکیج است ، گاهی داخل یک فانکشن ، گاهی داخل یک حلقه ی لوپ

## Lifetime of Variables:

زمانی که یک وریبل در مموری عمر میکنه

هنگامی که ران تایم از اسکوپ خارج شود ، یعنی بلاک کامل استفاده شود ، اگر وریبل به هیچ جا رفرنس  نشده باشد ، پاک میشود

گاربج کالکتور هیچ وقت package )global(  scope variable  رو پاک نمی کنه



### type comperable

تایپ استراکت در گو comperable هستن اگر همه ی فیلد هاشون برابر باشه ، آنگاه == , != نتیجه میده
 . ولی تایپ فانکشن compareble    نیست



### Functional Programming

یه نوع الگوی کد زدن هست که از چند تا قابلیت استفاده می کنه  ، شاید چند تا ویژگی گو نداشته باشه ولی اکثر قابلیت ها رو داره مثل موارد زیر :


+ **first_class_functions**

در زبان گو ، فانکشن ها first class   هستند

بعضی زبان های برنامه نویسی قابلیتی دارند که می توان، فانکشن را درون یک متغییر ریخت ، به قابلیت فرس کلاس فانکشن می گوند

و در کل بشه رفتار هایی که با وریبل های معمول مانند عدد یا استرینگ می توان انجام داد را با فانکشن ها نیز می توان انجام داد

https://golangbot.com/first-class-functions/


+ **Higher Order Functions**

 تابعی که بتوان  یک تابع به عنوان پارامتر بگیرد ، یا بتوان خروجی اش یک تابع باشد، از این قابلیت برخوردار است
 
 توجه : این به این معنی نیست که تابع مقدار دهی شده ( کانکریت) در ورودی یا خروجی استفاده شود ، این یعنی تایپ آن فانکشن است
 
همچنین توجه شود که نام تابع به عنوان ورودی یا خروجی استفاده نمی شود و تنها تعداد ورودی و تعداد خروجی آن تابع به عنوان متغییر مشخص است

 https://www.golangprograms.com/higher-order-functions-in-golang.html

```
         package main

        import (
            "fmt"
            "net/http"
        )

        func hello(w http.ResponseWriter, req *http.Request) {

            fmt.Fprintf(w, "hello\n")
        }



        func main() {

            http.HandleFunc("/hello", hello)

            http.ListenAndServe(":8090", nil)
        }
 ```
تنها تایپ hello به عنوان ورودی به HandleFunc داده میشود   



+ **closure in function**

تابعی که خروجی اش یک فانکشن باشه

```go

func makeAdder(x int) func(int) int {
    return func(y int) int {
        return x + y
    }
}

func main() {
    addFive := makeAdder(5)
    result := addFive(3)  // 5 + 3 = 8
    fmt.Println(result)    // Prints: 8
}

```

