
# NETWORK

![alt text](https://github.com/seyedmo30/Tips/blob/main/static/network.png)
## nat


لپ تاپ ما یه آی پی داره که توی روتر فقط معنی داره مثل 192.168.1.100 ولی وقتی درخواست می خواد به به اینترنت وصل شه باید Network address translation اتفاق بیفته یعنی پابلیک آی پی که  - isp - مخابرات به ما داده درخواست بکنه ، پاسخ که اومد با nat  دوباره به کامپیوتر داده بشه ، در حقیقت با nat میشه درخواست به بیرون داده یا پاسخ رو گرفت


اگر یک شبکه ی پرایویت داشته باشیم و همه ی آن ها از طریق یک IP static به اینترنت وصل شوند ، در این صورت از نت استفاده کردیم .


به منظور ایجاد یک NAT (Network Address Translation) برای ترافیک شبکه، می‌توان از دستور `iptables` در لینوکس استفاده کرد. این دستور به شما امکان می‌دهد تا
 قوانین ترافیک شبکه را تعریف و مدیریت کنید.
 برای پیکربندی NAT، می‌توان از دستورات زیر استفاده کرد:
 + فعال کردن NAT
 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
 + ترافیک ورودی به پورت 80 را به پورت 8000 هدایت کن
 iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-ports 8000

### dns over https (doh)

چون udp  دیکیریپت و انکریپت نمیشه ، می تونیم بعضی از درخواست ها رو با یه dns  خاص بندازیم تا رمزنگاری بکنه

+ dmz

توی روتر ها می تونیم آدرسی ست کنیم که از بیرون ًابل مشاهده باشه

با این که isp  یا مخابرات آدرس ثابت نمی ده ولی همون آیپی شاید ۲ روز ثابت باشه ، اگر این آی پی رو کال کنیم ، تا روتر میاد و اگر این قابلیت رو کانفیگ کنیم ، می تونیم از بیرون کامپیوتر خودمون رو ببنیم


### proxy

+ **forward proxy**
توی این روشمی تونیم امنیت و سکیوریتی کاربر رو بالا ببریم

مانند استفاده از شکن 

در این حالت اینترنت با آی پی واقعی کاربر روبرو نیست

```
user --------> proxy ------> internet -------> server

```

+ **reverse proxy**

در این حالت ما درخواست به سرور می زنیم و در پیش سرور در خواست ها به چندین سرور داخلی می رسه که ما نمی بینیم مانند load balancer

مثل nginx , load balancer

```
user  ------> internet --------> proxy -------> server

```


### لایه های شبکه

+ **application layer**

+ **Session Layer** 

توجه شود IP استیت لس هست و به صورت فیزیکال کانکشنی وجود ندارد ، تنها داده ارسال میشود

با این لایه می توان به صورت logical  کانکشن رو برقرار کنیم راه هایی مانند باز کردن پورت 


+ **transport layer**

در این لایه مسعولیت تیکه تیکه کردن داده و ارور هندل و کنترل ترتیب و صحت دریافت هندل میشه

دو پروتوکول اصلی TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) میشه مدیریت کرد سگمنت ها و پکت ها رو
+ **network layer**

در اینجا ارتباط بین نتوروک ها مطرح است و به صورت logical  و نه فیزیکال مسيله حل می شود . 

با استفاده از  IP (Internet Protocol) پکت ها رو به بیرون شبکه روتینگ کرد

+ **Data Link Layer**

در این لایه هنوز IP تعریفی ندارد و ارتباط بین ماشین در شبکه محلی LAN مطرح است

اینجا از MAC addresses استفاده میشه و نود های درون یک شبکه محلی هنوز از شبکه های محلی بیرونی خبری ندارد ، تنها MAC addresses های درونی رو میشناسن

+ **physical layer**

توی این لایه تنها بحث تبدیل ولتاژ منفی و مثبت به 0 و 1 هست


### url vs uri

+ **URI (Uniform Resource Identifier)**

یه استرینگ برای شناسایی یه منبعه می تونه یا آدرسش باشه ، یا نامش باشه ولی شناسه و یونیکه

+ **URL (Uniform Resource Locator)**

یکی از زیر مجموعه های URI هست و برای مکان یا ادرس در شبکه یا وب استفاده می شود و محدود به http , ftp  نیست

مولفه های زیر رو داراست :

پروتوکول ، هاست ، مسیر ، کوییری پارام



### Netwotk vs ipc

+ **network**

از انواع راه های کامیونیتی بین پراسس ها هستند ،
نتورک میتونه توی اینترنت ارتباط بین چند ماشین برقرار کنه

 با پروتوکل هایی مانند
 tcp_ip , http , ftp کار میکنه

سرعتش کمتره ، و یوزکیسش وب اپلیکیشن ها ، و .... هست

+ **ipc**


در حالی که ipc پردازش درون یک ماشین بدون نیاز به نتورک رو بر قرار میکنه

از روش هایی مانند اینا استفاده میکنه port , memory share , uds , message queue , 

sockets , pipes

Pipes :
کانال های یک طرفه در پردازش های سیستم عامل

یوزکیسش هم ارتباط با دیتابیس ، ارتباط چند ترد با هم ، و پراسس های os با هم است



### tls ( رمز نگاری نامتقارن )

در این حالت کلید خصوصی به هیچ در شبکه نمیرود ، بلکه هر دو توافق میکنند بر نوع الگوریتم ، ورژن و تایپ ، حال کلید عمومی و خصوصی با آن توافق ، تولید شده ، و عمومی منتشر میشود و با هم صحبت میکندد

نمونه شبیه سازی شده ی کلاینت و سرور در https 

پس به جای اشتراک کلید خصوصی در نتورک ، ابزار یا پروتوکول تولید در شبکه اشتراک میابد


```
{
  "handshake": [
    {

      "step": 1,
      "message": {
        "type": "Client Hello",
        "data": { 
          "version": "TLS 1.2",
          "supported_cipher_suites": ["..."],
          "random_number": "abc123randomclient"
        }
      }
    },
    {
      "step": 2,
      "message": {
        "type": "Server Hello",
        "data": {
          "chosen_cipher_suite": "...",
          "random_number": "def456randomserver"
        }
      }

    },
    {
      "step": 3,
      "message": {
        "type": "Server Certificate",
        "data": {
          "certificate": {
            "subject": "CN=example.com",
            "public_key": {
              "key": "..."
            }
          }
        }
      }
    },
    {
      "step": 5,
      "message": {
        "type": "Pre-Master Secret",
        "data": {
          "encrypted_secret": "..."

        }
      }
    },
    {
      "step": 6,
      "message": {
        "type": "Session Keys Generated"
      }
    }
  ]
}
```

### isp

پروایدر هایی که به کلاینت ها اینرنت میدن و خدماتشون ایجاد ارتباط با اینترنت هست
و با روش هایی مانند dsl از طریق سیم مانند مخابرات ، از طریق فیبر نوری ، wireless مانند ایرانسل و ماهواره مثل استارلینک
همچنین گاهی خدمات دیگه هم مانند هاست می توان  در اختیار کاربر گذاشت


### websocket

در گذشته ، برای اینکه کاربر درخواستی از سرور بکند ، با پروتوکل http این کار را انجام می داد ، به شکل تری هند شیک و بعد از اتمام در خواست ، ارتباط بسته می شد ، وب سوکت در یک پورت تعامل دو طرفه دارد و بعد از در خواست ، کانکشن بسته نمی شود ، هرگاه یکی از طرفین کانکشن را قطع کند ، ارتباط خاتمه می یابد

همچنین برای شروع از http استفاده می کند اما در ادامه websocket  بر قرار می کند . 

توجه شود socket در شبکه به معنی IP + PORT هست و با وب سوکت فرق دارد

### set proxy

نشون میده که با پروکسی درخواست ها فرق می کنه

+  curl https://api.ipify.org

185.234.123.657


+  curl -x socks5h://127.0.0.1:1080 https://api.ipify.org

139.345.456.77%  