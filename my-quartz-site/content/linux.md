# network

        sudo lsof -t -i:8000    //مشاهده PID روی پورت

        ls -l /proc/<PID>/cwd //یافتن دایرکتوری کامند برای اجرا       /usr/local/projects/data-aggrigator/cmd/server

        ls -l /proc/<PID>/exe //یافتن دایرکتوری فایل اگزکیوت        /tmp/go-build2963007683/b001/exe/main

        ip route // مشاهده دیفالت گیت وی

        nslookup //  مشاهده اینکه DNS درست کار می کند ، پیدا کردن IP هاست نیم ها همچنین domain name میدیم و ip میگیریم
        

+ مشاهده پرت های باز tcp udp 
        
            sudo apt install net-tools
            netstat -tulpn
  
+ گاهی برنامه توی محیط گرافیکی  gnome  مشکل میخوره برای بستنش ابتدا باید ps رو پیدا کنیم 

`ps aux | grep totem`


+ با دستور ifconfig می توان اطلاعات کلی ماشین مانند default gateway , netmask ,inet  را دید همچنین شبکه اصلی ماشین enp4s0 را دید همچنین شبکه های محلی مانند داکر هم قابل رویت است

                ifconfig
        
sudo kill -9 $(sudo lsof -t -i:8000)

+ restart network
```
sudo systemctl restart NetworkManager
```

scp root@1.2.3.4:/root/pcfilename.rar ./

مشاهده سایز فولدر 

    sudo du -hs volumes

پیدا کردن گنده ترین فایل ها

    find -type f -exec du -Sh {} + | sort -rh | head -n 5

+ keyring

به جای اینکه هر بار پسورد برای یه سری چیزا مانند vscode , wi fi ,ssh رو بخواهیم بزنیم 

یه بار این پسورد رو میزنیم و تا زمانی که لاگین هستیم ، نیازی به وارد کردن پسورد نیست

+ GPG

یه ابزار برای رمز نگاری نامتقارن هست و  با این دستور میشه کلید عمومی و خصوصی تولید کرد

`gpg --gen-key`


+ `sudo su -`

اگر برید روت باید shell  رو عوض کرد

`sudo chsh -s $(which zsh) root`

### cloud-init 
برای اجرای دستورات در سیستم عامل مانند تعریف یوزر ، ساخت کرونتب و اجرای بش اسکریپت و تمامی دستوراتی که با دسترسی سودو نیاز به اجرا هست . می توان گفت پس از اینیت کردن سیستم عامل ، با استفاده از cloud-init می توان دستوراتی در سیستم عامل اجرا کرد

    cloud-init status

#### env 
در صورتی که مقدار env را در ترمینال export کنیم ، بعد از ریلود شدن ، پاک می شن و برای ماندگاری باید در bash ذخیره کینم و در پایان، بش را source کنیم ، همچنین می توان برای استفاده همه ی یوزر ها ، در آدرس زیر ذخیره کرد

    /etc/environment



#### Package managers
ابزاری برای نصب برنامه و پیش نیاز ها و مدیریت آن ،برای دبیان apt هست و برای فدورا yum

#### service manager
برای استارت و استاپ شدن سرویس ها مثل systemd
, همچنین برای اینکه دستی سرویسی رو استاپ یا ریاستارت کنیم از دستور systemctl  استفاده میکنیم
همچنین با دستور enable , desable مشخص میکنیم که بعد از بوت شدت ، اتوماتیک استارت شود

#### Ansible
می تونه همزمان به کلی یرور وصل شه و یه دستور رو اگزکیوت کنه ، مثلا بجای اینکه ssh بزنیم به تک تک سرورا و شکن ست کنیم ....

#### Terraform
کانفیگ ها ی اولیه برای اینکه سرور بیاد بالا

#### limit docker
می تونیم بر بروی کانتینر ها لیمیت بزاریم

--cpus _ تعداد هسته هایی که در اختیار قرار میدیم رو مشخص می کنیم

CPU CFS scheduler period مطالعه شود

1000 milisecond در اختیار میزاریم

CPU CFS quota on the container مطالعه شود

Cpu realtime scheduler vs cpu cfs scheduler

#### shell
+ Bash

 خیلی از فیچر هارو نداره ، اتوکامپلیت نداره 
بعد از باز کردن بش ، بدون اینکه کی لاگین کردن از .bashrc می خونه و اصطلاحا می گن interactive non-login
  
+ Zsh

کلی فانکشن داره ، اتو کامپلیت خوبی داره ، میشه 
اکتنشن اضافه کرد بهش ،  
چیزایی که تو bashrc داریم:

Export path=
آدرس یه فایل باینری

#### Env
مقادیری در لینوکس به صورت کی ولیو ، اطلاعات زیر درونش است :

• System and user paths

• API keys and credentials

• Software configurations

• Default settings for shell and commands

+ Printenv / env 

دستور بالا تمام مقادیر را نمایش میدهد

ذخیره به صورت موقت : 
اکسپورت در ترمینال
ذخیره به صورت پایدار :

nano /etc/environment 
و اجرا
source /etc/environment 
البته در آدرس زیر هم میشه
`~/.profile` or `~/.bashrc` 

می تونیم توی دایرکتوری زیر هم چند فایل بسازیم 
/etc/profile.d/*.sh

#### standard streams
+ stdout
توی سیستم عامل  یه ابزاره که می شه با اون توی ترمینال یا کنسول استریم کرد . همچنین باید این میشناسن : descriptor 1 .

+ stderr
 برای چاپ ارور توی استریم می  ریزن .  همچنینdescriptor 2. شناسایی میشه

#### signals

+ SIGINT - Interrupt

شمارش ۲ هست ، زمانی که ماربر کنترل سی بزنه ، زمانی که کار بر بخواد گریسفول بیاد بیرون ، ما باید در این صورت تسک و برنامه ها رو کیلن آپ کنیم ،

+ SIGTERM - Termination

شماره ۱۵ ، زمانی که یه برنامه بخواد برنامه ما رو ببنده ، مانند بالایی است با این تفاوت که از سمت پروسس دیگه میاد

#### search
```
history | grep -- "--dev-url"
```


+ با این دستور می شه هر چند دقیقه یه اسکرین بر اساس مموری  سیستم عامل انداخت تا بعد از کرش کردن یا ترکیدن بدونیم چی عامل بوده

        atop -r /path/to/your/logfile -m


**Cgroup**

وظیفه دسته بندی چند تسک و پروسس با این انجام میشه ، همچنین برای گدیریت کردن و ایجاد محدودیت برای تسک ها(وظیفه محدودیت و کنترل با subservice است)


**Arm**

داستان طولانی داره ،یه ایده هست به نام risk  میگه به جای اینکه cpu کلی دستورات متنوع بتونه انجام بده ، یه سری دستور محدود ولی با سرعت بالا و مصرف برق کمتر جرا کنه ، و پیچیدگی دستورات بیفته سمت زبان های برنامه نویسی یا اسمبلی و یکی از خروجی های این ایده ، arm  بود و توی اپل اولین بار اومد و لپ تاپاش دیگه داغ نمیکردن ، arm یه سری قوانین و دستورات محدوده

 


+ یکی از دلایلی که با یوزر root  در لینوکس سخته کار کردن ، اینه که ما خیلی از تنظیمات رو روی یوزر خودمون می کنیم مثل zshrc یا config  هایی که توی آدرس `~/` انجام میدیم ، اگر بخواهیم با روت کار کنیم تمامی کانفیگ ها رو باید از `/home/mostafa/` بخونیم چون که `~` در روت و یوزر عادی فرق داره 


**compilition**

بعد از این که یه تولز رو توی لینوکس نصب میکنیم مثل kubectl  ، بعد از زدن تب دوست داریم به جای دیدن فایل های اون دایرکتوری ، دستورات کیوب رو ببینیم ، برای همین کامپلیشن اون رو راه اندتزی میکنیم ، آموزشش حتما سرچ زده بشه و کد اینجا گذاشته بشه

+ root fs vs boot fs در سیستم عامل

اگه اینو بفهمیم ، می فهمیم تفاوت ویرشوال ماشین و کانتینر
و اینکه الپاین چجوری با ۷ مگ ، ران میشه و برای ایمیج ویندوز ۲ گیگ و برای نصب رو ویندوز باید wsl



توی 

kernel داره

