### Threads vs. CPU Cores 

در حقیقت **CPU Cores** هسته های فیزیکی و واقعی  پردازنده های مدرن هستند که چند core  دارن .

در حالی که **thread** ها دنباله ای از دستورات هستند که قرار است توسط یک **CPU** اجرا شوند

حتی **single core** می تواند چندین **thread** رو به صورت غیر همزمان اجرا کند اما در لحظه تنها یک **thread** را اجرا می کند


### concurrency vs parallelism 


پاسخ : Concurrency یعنی "**مدیریت چند کار به طور هم‌زمان**" و Parallelism یعنی "**اجرای چند کار به طور هم‌زمان**". در Go ما با goroutineها concurrency داریم، و اگر روی چند core اجرا بشن، parallelism هم به دست میاد.

در پارالل هر سرویس بر روی یک ترد واقعی پراسس می شود در حالی که در کانکارنت چندین تسک می توان بر روی یک ترد پراسس شود همچنین در کانکارنت ترتیب و نظم اهمیتی ندارد

**مثال** فرض کنید یه فرد چندین کار رو بر عهده داره ولی هر ۵ دقیقه یه کار رو ول می کنه و کار دیگه رو ادامه میده 

ولی در خالت دیگه چندین نفر هر کدوم یه کار رو دارن انجام میدن 

خوبیش اینه دیگه کسی منتظر عوامل دیگه مثل انتظار چنل یا نتورک نمی مونه

**معایب** کانکارنسی

+ تست کردنش خیلی سخت بوده

+ حتی برنامه نوسام هوش و منطقشون خطی بوده و براشون سخته منطق همزمانی رو تو ذهنشون انتضاع کنن

+ **Context Switching**

وقتی سیستم عامل میخواد چنیدین پراسس رو انجام بده ، باید یه ترد رو به اشتراک بزاره ، یعنی یه پراسس ترد رو بگیره و بعد دوباره منتظر بمونه یه پراسس دیگه تا یه جایی بره جلو ، باز سیستم عامل ترد رو به پراسس بده ، این یعنی استیت و کانتکس پراسس باید ذخیره بشه و دوباره بازیابی بشه ، و اینکه خیلی هزینه داره 

کاری کا پروسس تو گولنگ میکنه  توی سیستم عامل همون کار رو کانتکس سویچینگ میکنه ، منظور p یا صف پراسس مجازی هست

زمانی که عملیات بر روی ترد  متوقف شده و می خواهد ادامه رو بر روی ترد دیگه ادامه دهد این اتفاق می افتد 

این اتفاق هزینه بر است و زمانی که بر روی ترد های واقعی کار می کنیم خیلی هزینه بر است ، اما زمانی که با goroutin ها کار می کنیم خیلی خیلی بهینه تر این مدیریت میشه


+ مزیت های گوروتین نسبت به ترد های os

خیلی سبک ترن استک در os 8mg  است اما در گوروتین 2kb

کانتکس سوییچینگ در گوروتین ها خیلی سبک تره از او اس

+ **user space**

کانتکس سویچ در گوروتین ها درون **user space** اتفاق می افته و هزینش خیلی کمتره - یعنی خود اون برنامه هندل می کنه بدون این که سیستم عامل بفهمه

سوال: چرا هزینه ی کانتکست سوییچ در گوروتین ها کمتره؟
- - چون نیاز نیست برای هر ترد از سیستم عامل درخواست ترد بزنه - **It doesn't involve a system call**

- - میزان مموری که نیاز داره خیلی ئایین تره - اطلاعاتی مانند ریجیستر کردن پراسس ، استک ، شماره گوروتین

- - وقتی OS بین threadها یا processها context switch می‌کنه، این در **kernel space** انجام می‌شه 

+ **Goroutines**

ترد های مجازی خیلی سبکی هستند که توسط runtime  مدیریت میشن ، در حقیقت به جای اینکه مدیریت ترد ها رو بندازیم رو دوش سیستم عامل ، خودمون میایم با این ترد های مجازی مدیریت می کنیم





+ **scheduler**

یکی از اجزای runtime است و وظیفه اش مدیریت اجرای گوروتین ها است

توجه شود مدل و یا تکنیک **M:N** هیچ ربطی به **M, P, G** نداره و قاطی نشن




### M:N scheduler 

این تکنیک یه روشه که تو یه سرویس بتونیم گوروتین ها رو هندل کنیم ، در حقیقت می خواییم بگیم که تعداد زیادی گوروتین می شه به تعداد محدودی ترد سیستم عامل ارتباط بگیره


- **M**

نماد گوروتین هاست و عددش می تون هزار یا میلیون باشه

گوروتین ها اساین می شن به **m**  ها


- **N (Number thread os)**

تعداد ترد های حقیقی سیستم عامل هست و بیشترین عدد می تونه تعداد ترد ها باشه مثلا 4 یا 8



### Go's Scheduler: M, P, G


- - M (Machine) (kernel threads)

 نماد ترد های سیستم عامل است


وقتی یک گوروتین آماده ی اجرا است ، اسکجولر آن را به یک **M** فعال ، لینک می کند


**M** موجودیتی است که گوروتین ها رو ران می کنه



- - **P (logical Processor)**

مسعول اجرای گوروتین ها است ، در حقیقت **پی** یک پروسسور لاجیکال است است

ترتیب گوروتین ها را در صف لوکال نگه می دارد

به صف پراسس میگیم local run queue _ lrq

توجه شود context  درون این نگه داری میشود


یک صف است و تعدادی گوروتین در صف خود دارد و آن ها را مدیریت کرده و در صورت اجرا ، آنها را به **M** می دهد


 - - **G (Goroutine)** (user threads)
 نماد گوروتین هاست


```
P1 -> M1
     |-> G1
     |-> G2

P2 -> M2
     |-> G3
     |-> G4
```
![alt text](images/goroutin1.png)

- - **Preemption** 

به صورت دوره ای بررسی می کند که گوروتین cpu رو اشغال نکند و به بقیه گوروتین ها هم بدهد

- - **Work Stealing** 

وقتی گوروتین بلاک شده مثلن منتظر نتورک یا i/o سیستم عامل ، در این صورت وظیفه این بخش این است که ترد  پردازنده را به گوروتین بعدی دهد 

به عبارت دیگر اگر صف لوکال یک P  خالی باشدباید از صف یک P دیگر برداشت

- - **Work Stealing** vs **Preemption** 

پری امشن نظارت می کنه که یه گوروتین تمام ریسورس ترد رو درگیر نکنه در حالی که ورک استیلینگ نظارت می کنه بر اینکه اگر چند صف پراسسور داریم و یکی خالی شد ، بره و از صف های پراسسور های دیگه گوروتین بیاره ، اگر نبود از گلوبال صف بیاره

- - **Goroutine States**

حالت های گوروتین ها ، شامل **Runnable** به معنی آماده برای شروع کار ، **Running** به معنی در حال اجرا و در نهاییت **Waiting** به معنی بلاک برای انتظار یک ایونت مانند گرفتن از چنل یا نتورک

 + + **GOMAXPROCS**
 
  یه متغییر که میشه تعداد ترد هارو مشخص کرد ، به صورت دیفالت عدد هسته های پردازنده در سیستم عامل است

### deep dive


سوال ، زمانی که بخواهیم کانتکس سوییچ انجام دهیم زمانی که منتظر io  هستیم ، چگونه انجام میشود ؟
جواب پابین

#### system call

به این مفهوم که پراسس به os میگه میخواد io  کنه 

مثلن یه فایل بخونه

##### context switching sync system call

ابتدا تعریف sync :

 درخواست هایی به os که پاسخ داده میشود ، و program بلاک میشه تا زمانی که کامل بشه مثل read کردن فایل ، توجه شه که اون برنامه قفل شده و کلک رشتی گوروتین ها به شکل زیر است ، 

زمانی که یکی از گوروتین ها می خواد io بخونه ، همه ی گوروتین های در صف باید منتظر بمونن ، راه حل اینه که یه ترد دیگه میگیریم و پراسس رو انتقال میدیم به m  جدید ، در تصویر پایین ابتدا m2 وجود نداشت ، ولی بعد این که g1 درخواست sync system call کرد صف پراسس ها جابجا شد به m2 جدید

![alt text](images/g.png)

##### context swiching async system call

بر حلاف مورد اول ، در این مورد میشه در خواست داد و منتظر call back و یا notification بود و کار های دیگر هم ادامه داد مانند درخواست http get

در این حالت os این امکان رو میده که با epoll بفهمیم هر وقت پاسخ اومد ، بیایم ادامه بدیم

+ netpoller : 

یه اینترفیس در گولنگ است که به epoll لینوکس وصل میشه و خودش هندل میکنه گوروتین ها رو ، و جدول notif ها رو داره ، به این صورت که اگر یه گوروتین 


ترتیبش به این صورت هست که ابتدا گوروتین درون اسکجولر هست
و زمانی که بخواد منتظر epoll  لینوکس باشه ، از os thread خارج میشه و میره در netpoller
و اونجا با استفاده از file descriptor  پولینگ میکنه

در اینروش بر خلاف روش سینک ، نیاز به یک ترد دیگر نیست


![alt text](images/g-1.png)

### work stealing

به این معنی که اگه یه لاجیکال پروسس خالی باشه 
۱ چک میکنه از لاجیکال پروسس های دیگه گوروتین استیل کنه و نصف صف رو میدزده


۲ اگه نتونست از گلوبال رانیبل کیو استیل میکنه

۳ اگه نتونست از netpoller  میگیره


![alt text](images/g-2.png)





###  deadlock , block , sendq , recvq : 

وقتی گوروتین میخواد از چنل برداره یا بزاره ، در صورتی که یا آنبافر باشه و یا بافر پر باشه  و هیچ ریسیور و یا سندری نباشه بلاک میشه و میره تو صف recvq , sendq  اما زمانی که هیچ گوروتینی نباشه که از بلاکی اینا رو در بیاره ، دد لاک میشه



channels underneath


![alt text](images/iii.png)


هر چنل یه استراکت است و یه سری اینتیتی داره ، مهم ترین آنها
یه mutex  داره برای لاک ، یه buf  داره که آدرس داده ها هست و اگر چنل آنبافر باشه ، این خالیه ، sendq , recvq  آدرس های گوروتین ها هستن که یا نتونستن ریسیو کنن یا نتونستن سند کنن ، در حقیقت تایپشون waitq  هست و این خود یک لینکد لیست هست ،  


![alt text](images/iii1.png)


و sudog اطلاعات گوروتین رو نگه میداره ، elem  آدرس اون هست و g  آبجکت اون

وقتی بافر خالیه و یه گوروتین می خواد ریسیو کنه ، می ره تو لیست recvq و gopark()  رو کال میگنه.
 اسکجولر اون رو میبره ته صف لاجیکال پراسس، حالا فرض کنیم گوروتینی که توی چنل send میکنه میاد و و به recvq نگاه میکنه و direct  داده رو میده به g1 و پس از این که داده رو مستقیم گذاشت تو استک g1 سپس goready)g1( رو کال می کنه

نکته ، تنها جایی g 1 داده direct کپی میشه به stack گوروتین g2  در شرایطی هست که یا آنبافر باشه و یا recvq پر باشه


وقتی بافر پر هست و یه گوروتین میخواد send  کنه نمی تونه بجاش send gopark)(  رو کال میکنه و می ره تو لیست منتظر ها ، حال اگر یه گوروتین بخواد داده بخونه ، از بافر بر میداره ، و بعد از خالی شدن بافر ، گوروتین که پارک شده ، اجرا میشه

+ gopark()

وقتی یک goroutine نتونه جلو بره یعنی یا آنبافره و یا بافر پره - برای سند کردن- یا خالیه - برای ریسیو کردن- در این صورت ابتدا رانتایم اون گوروتین رو پارک میکنه معنی :

یعنی این گوروتین رو پارک کن و به اسکجولر برگرد و اون گوروتین میره ته صف پراسسور

+  goready()

وقتی شرایط unblock شدن فراهم شد: receiver آماده میشه برای یه sender یا buffer جا باز می‌کنه runtime با goready() اون goroutine رو از حالت پارک‌شده در میاره و می‌ذاره دوباره توی صف اجرای scheduler.

# **channels**

راه ارتباطی بین گوروتین ها ، متغییر هایی هستند که بین ترد ها مشترکند



## انواع چنل ها 


**حتما حتما برای اینکه بفهمن عمیقیم از sendq و recq باید استفاده کنیم**


### unbuffer 

+ زمانی که بخواهیم داده **سینک بین گوروتین ها** دریافت کنیم توجه شود هیچ ظرفیتی ندارد یعنی حتی یک هم نیست و تنها زمانی می تونیم توش بزاریم که قبلش یکی رسیو کرده باشه

sender بلاک میشه مگر اینکه receiver آماده باشه → میره داخل sendq.

receiver بلاک میشه مگر اینکه sender آماده باشه → میره داخل recvq.

پس gopark() و goready() خیلی زیاد استفاده میشه.




+ زمانی که مطمعنیم پاسخ گرفته شده از چنل ، مخصوص در خواست است ( توجه شپد در چنل بافر استیت لس است و نمی دانیم مسیج مخصوص کدام درخواست است، مگر این مه متا دیتا داشته باشد) 

+ می توان به عنوان سیگنال بین گوروتین ها استفاده کرد

+ در کل مخصوص زمانی است که می خواهیم داده ای مشخص را بگیریم ، اما زمان دریافت را نمی دانیم ، به جای انتظار برای یم متغییر از یک فانکشن ، منتظر چنل می مانیم و می توانیم سیاست هایی مانند تایم اوت یا ریپلای گذاشت


  توجه: چنل آنبافر  یعنی طول صفر است ! یعنی اگر به چنل آنبافر بعد از ساختن ، مقدار دهیم ددلاک می شود! 
  
  تنها در صورتی می توان استفاده کرد که در گوروتین جدا ابتدا منتظر برداشتن از چنل باشیم و به محض ریختن در چنل آنبافر، آن برداشته شود . در نتیحه ابتدا باید منتظر باشیم سپس داده در آن بریزیم .


### buffered 

+ نیاز به گرفتن داده **بین گوروتین ها به صورت همزمان و مرتب** نباشد - آسینک

+ زمانی استفاده میشود که که حجم زیادی مسیج که ترتیب آن ها برای ما اهمییتی ندارد استفاده می شود

+ توجه شود چون ترتیبش مشخص نیست و **stateless** هستند بهتره اطلاعات درخواست کننده رو هم توی استراکت باریم ، همچنین در صورتی که چنل پاسخ است ، بهتره علاوه بر correlation id  که نشان دهد برای کدام درخواست است ، error رو هم برگردانیم
+ زمانی که می خواهیم برای تعداد اکتیویتی ها محدودیت بزاریم ، مثلن همزمان تا سقف ۵ درخواست http  داشته باشیم ، در این صورت از این چنل ها استفاده کرده و هر کار که تموم شد یکی از بافر ورو میداریم و هر کار که افزودیم ، یه نشانه به بافر میدیم

+ 


### Directional
+ send-only - chan<- - از دید کلاینت ، فقط می توان به چنل داده فرستاد
+ recevie-only - <-chan - از دید کلاینت ، فقط می توان از چنل داده دریافت کرد




### راه حل برای جلوگیری از deadlock

+ **استفاده از چنل directional** 

اگر محدود کنیم ، احتمال خطا کم میشود مثلن از چنلی باید بخوانیم ، ولی اشتباهی در آن بریزیم

+ **دقت در معماری**

باید معماری گوروتین ها طوری باشد که نیازمندی دوری - حلقوی نشود - 

#### نکات چنل ها
+ **تایم اوت استفاده شود Timeouts**

شاید به دد لاک نرسد ولی می تاون برنامه را تا بینهایت منتظر گذاشت

+ **محدودیت مناسب ظرفیت چنل**

باید در مقدار دهی ظرفیت دقت کرد ، شاید ظرفیت کم داده شود و deadlock  شود

+ **کلوز کردن**

بعد اتمام کار ، اطمینان حاصل کنید که چنل بسته شده

+ **Deadlock Detection**

`go run -race`

+ **unbuff**
  دقت شه ابتدا ارسال نکنیم به آنبافر
```
  func main() {
    ch := make(chan int)
    ch <- 42 // Deadlock because no goroutine is reading from the channel
} 
```

### error handling by channels

در مواردی که یک ورکر در یک حلقه بی نهایت ، از یک بافرد چنل می خونه ، ترتیب درخواست ها رو به آسونی نمیشه تشخیص داد و اینکه کدام درخواست مال کدام پاسخ است می توان با استراکت زیر این را مشخص کرد :

```go
type Response struct {  
    RequestID int  
    Message    string  
    Error      error  
}  

func worker(req Request, wg *sync.WaitGroup, resCh chan<- Response) 

```
با این struct  راحت می توان پاسخ ها رو تریس کرد

