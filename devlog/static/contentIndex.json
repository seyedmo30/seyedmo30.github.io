{"cache":{"slug":"cache","filePath":"cache.md","title":"cache","links":[],"tags":[],"content":"redis methods\nINCR\nبه یک کلید که مقدارش عدد هست یکی پلاس پلاس میکنه ، مثلا تعداد بازدید سایت و یا تعداد رکوعست یه یوزر\nn, err := rdb.Incr(ctx, &quot;requests:page_view&quot;).Result()\nINCRBY\nدقیقا مثل بالایی تنها تعداد دلخواه می افزاید\nn, err := rdb.IncrBy(ctx, &quot;user:123:score&quot;, 5).Result()\nEXPIRE\nمی توان زمان انقضا ست کرد\nok, err := rdb.Expire(ctx, &quot;session:abc&quot;, time.Hour).Result()\nTTL\nزمان باقی مونده برای انقضا رو میده\ndur, err := rdb.TTL(ctx, &quot;session:abc&quot;).Result() // dur can be -2 (no key) or -1 (no expire) or &gt;=0\nHSET / HGET\nبه صورت کلی نامی که می زاریم بهتره گویای همه چیز باشه و اگر خیلی بلند شد ، بهتره اون رو هش کنیم تا راحت تر فچ بشه\n_, _ = rdb.HSet(ctx, &quot;user:123&quot;, &quot;name&quot;, &quot;Alice&quot;, &quot;email&quot;, &quot;a@x.com&quot;).Result()\nname, _ := rdb.HGet(ctx, &quot;user:123&quot;, &quot;name&quot;).Result()\nm, _ := rdb.HGetAll(ctx, &quot;user:123&quot;).Result() // map[string]string\ntermonology\nCache-Aside\nتقریبا همه از این پترن استفاده میکنیم ، به پترنی که در کنار سورس اف تورف از یه کش استفاده کنه و به این صورت که اول کش رو ببینیم اگه نبود از منبع اصلی بگیریم و تو کش بزاریم\n\nکی باید از کش استفاده کنیم :\n\nزمانی که حجم رید بالا باشه ، میشه نتیجه گرفت که میزان تغییرات کمتر از خواندن است\n\nکجا نباید استفاده شه؟\n\nزمانی که بیشتر حجم رایت هست ، زمانی که داده به شدت حیاطی است و نباید inconsistancy رخ بده\nCache Decorator (Repo Layer)\nیکی از معماری ها و راه های ایمپلمنت کش است و به این صورت که ابتدا لایه ی ریپوزیتوری رو کامل میکنیم ، سپس یه لایه بالاتر از کش استفاده میکنیم و در صورتی که در کش نبود ،   از ریپو استفاده میکنیم ، یا اگر Write بود کلید کش رو حذف میکنیم.\nتوجه شود در همین لایه کلید های invalid رو هندل میکنیم به این صورت که اگر در ریپو آپدیت شد ، از کش حذف می کنیم\nObserver / Event-Based\ncache stampede\nفرض کنید همزمان چندین درخواست به کش می رود و کلید مشخصی میخوان و کش در اون لحظه نداره یا واقعا نداره و یا منقضی شده، سپس درخواست ها به سمت منبع اصلی میره در حالی که درخواست ها تکراری هستند\n\nsingleflight\nlock/promise in Redis\nCache warming / proactive refresh\n\nsingleflight\nابزار اینترنال گولنگ برای جلوگیری از کش استمپد\nگاهی کلی درخواست تکراری و در زمان خیلی محدود به دیتابیس و یا حتی ردیس و یا تردپارتی میره که داده ی تکراری رو فچ کنه و مطمئنیم تو اون بازه پاسخ ها تکراری هستند ، در این صورت می تونیم به جای استفاده از کش و مدیریت کردن آن از پکیج زیر استفاده کنیم . توضیحات بیشتر توی قسمت سینک گولنگ\nDistributed lock/promise in Redis\ngithub.com/go-redsync/redsync\nTTL jitter\nگاهی برنامه زمان اگسپایر رو جوری ست می کنه که در یک زمان نزدیک بیشتر کلید ها منقضی میشن و در نتیجه درخاست های زیادی همزمان به منبع اصلی میره ، برای جلو گیری از این ، عمر کلید های کش رو با متغییر بدیم :\nttl := 60*time.Second + time.Duration(rand.Intn(10))*time.Second\nCache warming / proactive refresh\nیه سری داده ها مطمعنیم که خیلی استفاده میشن پس بدون اینکه منتظر باشیم اکسپایر شن ، خودمون پیش دستی می کنیم و اون ها رو رفرش می کنیم\nInstrumentation &amp; alerting &amp; Stats\nاین که آمار داشته باشیم ، ردیس به صورت پیش فرض آمار نمیده و میشه توی پرومتيوس ریخت\n\ncache_hits\n\nچه تعداد درخواست میره سمت ردیس\n\ncache_misses\n\nچه تعداد درخواست تو ردیس نیست و میره منبع اصلی\n\ninflight_requests\n\nچه تعداد درخواست تکراری می ره سمت منبع - رعایت نکردن سینگل فلایت -\n\nwaiters\n\nچه تعداد منتظر و لاک هستن\nKey naming\nبهترین نام گذاری\nservice:entity:region:id\nمثال :\nmarket:book:BTC-ETH:level"}}